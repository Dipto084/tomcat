
.. _program_listing_file_src_cpp_model_pipeline_estimation_Estimator.h:

Program Listing for File Estimator.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_cpp_model_pipeline_estimation_Estimator.h>` (``src/cpp/model/pipeline/estimation/Estimator.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <memory>
   #include <set>
   #include <string>
   #include <unordered_set>
   #include <vector>
   
   #include <eigen3/Eigen/Dense>
   #include <nlohmann/json.hpp>
   
   #include "pgm/DynamicBayesNet.h"
   #include "pgm/EvidenceSet.h"
   #include "utils/Definitions.h"
   #include "utils/Tensor3.h"
   
   namespace tomcat {
       namespace model {
   
           //------------------------------------------------------------------
           // Structs
           //------------------------------------------------------------------
   
           struct NodeEstimates {
   
               std::string label;
   
               Eigen::VectorXd assignment;
   
               // Probabilities or densities calculated for n data points over
               // several time steps. If an assignment is provided, there will be
               // only one matrix in the vector containing the estimates for each
               // one of the data points and time steps. If no assignment is given,
               // there will be as many matrix estimates as the cardinality of the
               // node. In sum, there will be estimates for each possible
               // assignment the node can have.
               std::vector<Eigen::MatrixXd> estimates;
           };
   
           struct CumulativeNodeEstimates {
   
               std::string label;
   
               Eigen::VectorXd assignment;
   
               // The external vector represents the content for each one of the
               // executions of the estimation process. In a cross-validation
               // procedure,the size of this vector will be defined by the number
               // of folds. The internal vector store estimates for each one of the
               // possible node's assignments. This will only happen if no fixed
               // assignment was provided, otherwise, this vector will have size 1
               // as it will contain estimated for a single assignment only. Single
               // assignments make sense when a inference horizon of size > 0 is
               // used.
               std::vector<std::vector<Eigen::MatrixXd>> estimates;
           };
   
           class Estimator {
             public:
               //------------------------------------------------------------------
               // Constructors & Destructor
               //------------------------------------------------------------------
   
               Estimator();
   
               Estimator(std::shared_ptr<DynamicBayesNet> model,
                         int inference_horizon,
                         const std::string& node_label,
                         const Eigen::VectorXd& assignment = Eigen::VectorXd(0));
   
               virtual ~Estimator();
   
               //------------------------------------------------------------------
               // Copy & Move constructors/assignments
               //------------------------------------------------------------------
   
               // Copy constructor and assignment should be deleted to avoid
               // implicit slicing and loss of polymorphic behaviour in the
               // subclasses. To deep copy, the clone method must be used.
               Estimator(const Estimator&) = delete;
   
               Estimator& operator=(const Estimator&) = delete;
   
               Estimator(Estimator&&) = default;
   
               Estimator& operator=(Estimator&&) = default;
   
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               NodeEstimates get_estimates_at(int time_step) const;
   
               void keep_estimates();
   
               void clear_estimates();
   
               //------------------------------------------------------------------
               // Virtual functions
               //------------------------------------------------------------------
   
               virtual void prepare();
   
               //------------------------------------------------------------------
               // Pure virtual functions
               //------------------------------------------------------------------
   
               virtual void estimate(const EvidenceSet& new_data) = 0;
   
               virtual void get_info(nlohmann::json& json) const = 0;
   
               virtual std::string get_name() const = 0;
   
               //------------------------------------------------------------------
               // Getters & Setters
               //------------------------------------------------------------------
               NodeEstimates get_estimates() const;
   
               CumulativeNodeEstimates
               get_cumulative_estimates() const;
   
               int get_inference_horizon() const;
   
               void set_training_data(const EvidenceSet& training_data);
   
               const std::shared_ptr<DynamicBayesNet>& get_model() const;
   
             protected:
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               void copy_estimator(const Estimator& estimator);
   
               //------------------------------------------------------------------
               // Data members
               //------------------------------------------------------------------
               std::shared_ptr<DynamicBayesNet> model;
   
               // Data used to train the model. Baseline methods can use the
               // information in the training set to compute their estimations
               // instead of test data.
               EvidenceSet training_data;
   
               // Observed data to perform estimations. More data points can be
               // appended as estimations are made. Each derived class must store
               // computations to avoid recalculations as new data is available.
               EvidenceSet test_data;
   
               // Node to compute estimates, its fixed assignment (optional if
               // inference_horizon = 0) and estimates
               NodeEstimates estimates;
   
               // Node to compute estimates, its fixed assignment and cumulative
               // estimates
               CumulativeNodeEstimates cumulative_estimates;
   
               // An inference horizon determines if the task is a prediction (> 0)
               // or an inference (= 0). If it's a prediction, the horizon
               // determines up to how much further in the future predictions are
               // made.
               int inference_horizon;
           };
   
       } // namespace model
   } // namespace tomcat
