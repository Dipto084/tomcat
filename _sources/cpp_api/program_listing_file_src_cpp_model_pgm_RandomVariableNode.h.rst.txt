
.. _program_listing_file_src_cpp_model_pgm_RandomVariableNode.h:

Program Listing for File RandomVariableNode.h
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_cpp_model_pgm_RandomVariableNode.h>` (``src/cpp/model/pgm/RandomVariableNode.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Node.h"
   
   #include "../utils/Definitions.h"
   #include "cpd/CPD.h"
   
   namespace tomcat {
       namespace model {
   
           //------------------------------------------------------------------
           // Forward declarations
           //------------------------------------------------------------------
   
           class RandomVariableNode;
   
           //------------------------------------------------------------------
           // Structs
           //------------------------------------------------------------------
   
           class RandomVariableNode : public Node {
             public:
               //------------------------------------------------------------------
               // Constructors & Destructor
               //------------------------------------------------------------------
   
               RandomVariableNode(std::shared_ptr<NodeMetadata>& metadata,
                                  int time_step = 0);
   
               RandomVariableNode(std::shared_ptr<NodeMetadata>&& metadata,
                                  int time_step = 0);
   
               ~RandomVariableNode();
   
               //------------------------------------------------------------------
               // Copy & Move constructors/assignments
               //------------------------------------------------------------------
               RandomVariableNode(const RandomVariableNode& node);
   
               RandomVariableNode& operator=(const RandomVariableNode& node);
   
               RandomVariableNode(RandomVariableNode&&) = default;
   
               RandomVariableNode& operator=(RandomVariableNode&&) = default;
   
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
               std::string get_description() const override;
   
               std::unique_ptr<Node> clone() const override;
   
               std::string get_timed_name() const override;
   
               void reset_cpd_updated_status();
   
               void update_cpd_templates_dependencies(NodeMap& parameter_nodes_map,
                                                      int time_step);
   
               void clone_cpd_templates();
   
               Eigen::MatrixXd
               sample(std::shared_ptr<gsl_rng> random_generator,
                      const std::vector<std::shared_ptr<Node>>& parent_nodes,
                      int num_samples,
                      bool equal_samples = false) const;
   
               Eigen::MatrixXd
               sample(std::shared_ptr<gsl_rng> random_generator,
                      const std::vector<std::shared_ptr<Node>>& parent_nodes,
                      int num_samples,
                      Eigen::MatrixXd weights,
                      bool equal_samples = false) const;
   
               Eigen::MatrixXd sample_from_conjugacy(
                   std::shared_ptr<gsl_rng> random_generator,
                   const std::vector<std::shared_ptr<Node>>& parent_nodes,
                   int num_samples) const;
   
               Eigen::VectorXd get_pdfs(
                   const std::vector<std::shared_ptr<Node>>& parent_nodes) const;
   
               void update_parents_sufficient_statistics(
                   const std::vector<std::shared_ptr<Node>>& parent_nodes);
   
               void add_to_sufficient_statistics(const Eigen::VectorXd& sample);
   
               void reset_sufficient_statistics();
   
               void freeze();
   
               void unfreeze();
   
               void add_cpd_template(std::shared_ptr<CPD>& cpd);
   
               void add_cpd_template(std::shared_ptr<CPD>&& cpd);
   
               std::shared_ptr<CPD>
               get_cpd_for(const std::vector<std::string>& parent_labels) const;
   
               // -----------------------------------------------------------------
               // Getters & Setters
               // -----------------------------------------------------------------
               int get_time_step() const;
   
               void set_time_step(int time_step);
   
               void set_assignment(Eigen::MatrixXd assignment);
   
               bool is_frozen() const;
   
               void set_cpd(const std::shared_ptr<CPD>& cpd);
   
               const std::shared_ptr<CPD>& get_cpd() const;
   
             private:
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               void clone_cpd();
   
               void copy_node(const RandomVariableNode& node);
   
               std::string
               get_unique_key_from_labels(std::vector<std::string> labels) const;
   
               // -----------------------------------------------------------------
               // Data members
               // -----------------------------------------------------------------
   
               // Time step where the node shows up in the unrolled DBN. This
               // variable will be assigned when a concrete timed instance of this
               // node is created and assigned to a vertex in an unrolled DBN.
               int time_step = 0;
   
               // CPD is a shared pointer because multiple nodes can have a CPD
               // that depend on the same set of parameters.
               // A node can also have more than one CPD, each one referring to a
               // conditional distribution given a set of different parents. For
               // instance, a State node in a HMM will likely have two CPDs: one
               // for the first time step with no parent nodes associated and
               // another one to the following time steps with a State from the
               // previous time step as a parent.
               // The key in this data structure is a string that uniquely identify
               // the set of parents of the node to which the CPD is related.
               std::unordered_map<std::string, std::shared_ptr<CPD>> cpd_templates;
   
               // Conditional probability distribution of the timed instance of the
               // node in the unrolled DBN. The node template contains a list of
               // possible CPDs that can be associated with it. Once a concrete
               // timed instance of the node is created in the unrolled DBN, the
               // set of parents of such node is known and its CPD can be fully
               // determined.
               std::shared_ptr<CPD> cpd;
   
               bool frozen = false;
           };
   
       } // namespace model
   } // namespace tomcat
