
.. _program_listing_file_src_cpp_pro_gen_zombieworld_generator.cpp:

Program Listing for File zombieworld_generator.cpp
==================================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_cpp_pro_gen_zombieworld_generator.cpp>` (``src/cpp/pro_gen/zombieworld_generator.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #include "Pit.h"
   #include "World.h"
   #include <boost/program_options.hpp>
   #include <boost/random/mersenne_twister.hpp>
   #include <boost/random/uniform_int_distribution.hpp>
   #include <fstream>
   #include <iostream>
   
   using namespace std;
   boost::random::mt19937 gen; // Global randomness object
   namespace po = boost::program_options;
   
   AABB chooseZombieworldAABB(int idCtr, Pos* topLeft, Pos* bottomRight) {
       if (idCtr % 2 == 0) {
           Pos newBottomRight(*bottomRight);
           newBottomRight.setY(
               (*topLeft).getY()); // We are adding a Pit so we want the AABB to be
                                   // much flatter
   
           boost::random::uniform_int_distribution<> dist(1, 100);
           int rand = dist(gen);
   
           // Choose between an air, water or lava pit
           if (rand <= 25) {
               Pos newTopLeft(*topLeft);
   
               newTopLeft.shiftY(1);
               newBottomRight.shiftY(
                   1); // Move both above ground level for an air pit which achives
                       // the effect of an empty plot
   
               Pit airPit(idCtr, "air", &newTopLeft, &newBottomRight);
               return airPit;
           }
           else if (rand > 25 && rand <= 75) {
               Pos newTopLeft(*topLeft);
               newTopLeft.shiftY(-2); // In this case I'm chosing to offset the
                                      // base Y by -2 so we have a deeper water pit
   
               Pit waterPit(
                   idCtr,
                   "grass",
                   &newTopLeft,
                   &newBottomRight); // Start by creating a pit of grass which is
                                     // simply an AABB filled with grass
   
               waterPit.generateBox("water",
                                    3,
                                    3,
                                    1,
                                    0,
                                    3,
                                    3); // Add a box of water to it
   
               // Randomly add other blocks to give the effect of randomization
               waterPit.addRandomBlocks(30, "sand", &gen, 0, 1, 2, 0, 1, 0);
               waterPit.addRandomBlocks(20, "water", &gen, 0, 0, 2, 0, 0, 0);
               return waterPit;
           }
           else {
               Pit lavaPit(idCtr, "grass", topLeft, &newBottomRight);
               lavaPit.generateBox("lava", 3, 2, 0, 0, 1, 3);
               lavaPit.addRandomBlocks(10, "grass", &gen, 1, 1, 0, 0, 1, 1);
               lavaPit.addRandomBlocks(
                   30,
                   "cobblestone",
                   &gen); // Example showing use of all default values
               lavaPit.addRandomBlocks(10, "lava", &gen, 1, 0, 0, 0, 1, 1);
               return lavaPit;
           };
       }
   
       else {
           AABB aabb(idCtr, "room", "planks", topLeft, bottomRight);
           return aabb;
       }
   }
   
   void generateAABBGrid(
       World* worldptr, int N, int sep, int AABB_size, string material) {
   
       // Add the first one
       int idCtr = 1;
       Pos prevTopLeft(1, 3, 1);
       Pos prevBottomRight(AABB_size, 3 + AABB_size, AABB_size);
   
       AABB prevAABB(idCtr, "room", material, &prevTopLeft, &prevBottomRight);
       (*worldptr).addAABB(&prevAABB);
   
       // Use relative coordinates for the "previous" AABB to generate the rest at
       // each step
       while (idCtr <= (N * N - 1)) {
           idCtr++;
   
           if ((idCtr - 1) % N == 0) {
               // Condition for when a row in the grid is complete and we move onto
               // the next one
   
               Pos topLeft(1, 3, 1);
               topLeft.setZ(prevBottomRight.getZ() + sep);
               Pos bottomRight(
                   AABB_size, 3 + AABB_size, topLeft.getZ() + AABB_size);
   
               AABB curAABB = chooseZombieworldAABB(
                   idCtr,
                   &topLeft,
                   &bottomRight); // Choose the AABB to add. DOESN'T change topLeft
                                  // and bottomRIght
               (*worldptr).addAABB(&curAABB);
   
               prevTopLeft = topLeft;
               prevBottomRight =
                   bottomRight; // Set as if prev AABB was a room for consistency.
                                // Direct result of the fact that choosing an AABB
                                // doesn't change the coordinates
           }
           else {
               // Condition for the next AABB in the current row
   
               Pos topLeft(prevTopLeft);
               topLeft.setX(prevBottomRight.getX() + sep);
   
               Pos bottomRight(prevBottomRight);
               bottomRight.setX(topLeft.getX() + AABB_size);
   
               AABB curAABB = chooseZombieworldAABB(
                   idCtr,
                   &topLeft,
                   &bottomRight); // Choose the AABB to add. DOESN'T change topLeft
                                  // and bottomRIght
               (*worldptr).addAABB(&curAABB);
   
               prevTopLeft = topLeft;
               prevBottomRight =
                   bottomRight; // Set as if prev AABB was a room for consistency.
                                // Direct result of the fact that choosing an AABB
                                // doesn't change the coordinates
           }
       }
   }
   
   void generateAllDoorsInAABB(AABB* aabb) {
       // Get edge midpoints for the AABB because that is where the doors will be
       // placed
       vector<Pos> edges = (*aabb).getEdgeMidpointAtBase();
       Pos topEdgeMid(edges.at(0));
       Pos rightEdgeMid(edges.at(1));
       Pos bottomEdgeMid(edges.at(2));
       Pos leftEdgeMid(edges.at(3));
   
       // Since points are at base we want them to be at base + 1
       topEdgeMid.shiftY(1);
       bottomEdgeMid.shiftY(1);
       leftEdgeMid.shiftY(1);
       rightEdgeMid.shiftY(1);
   
       // Use the coordinates to create door blocks
       Block topDoor("door", &topEdgeMid);
       Block bottomDoor("door", &bottomEdgeMid);
       Block leftDoor("door", &leftEdgeMid);
       Block rightDoor("door", &rightEdgeMid);
   
       // Add it to the AABB's doors
       (*aabb).addBlock(&topDoor);
       (*aabb).addBlock(&bottomDoor);
       (*aabb).addBlock(&leftDoor);
       (*aabb).addBlock(&rightDoor);
   }
   
   void generateBlocks(World* worldptr) {
       for (auto& aabb : *(*worldptr).getAABBList()) {
           if (strcmp(aabb.getType().c_str(), "pit") != 0) {
               generateAllDoorsInAABB(&aabb);
           }
       }
   }
   
   void generateBoundingWalls(World* world) {
       AABB firstAABB = (*(*world).getAABBList()).front();
       AABB lastAABB = (*(*world).getAABBList()).back();
   
       // Create boundary
       Pos boundaryTopLeft(firstAABB.getTopLeft());
       boundaryTopLeft.shiftX(-4);
       boundaryTopLeft.shiftY(-3);
       boundaryTopLeft.shiftZ(-4);
   
       Pos boundaryBottomRight(lastAABB.getBottomRight());
       boundaryBottomRight.shiftX(4);
       boundaryBottomRight.shiftZ(4);
   
       AABB boundingBox(
           0, "boundary", "cobblestone", &boundaryTopLeft, &boundaryBottomRight);
       (*world).addAABB(&boundingBox);
   
       // Create Internal Separator 1
       Pos separator1BottomRight(boundaryBottomRight);
       separator1BottomRight.shiftX(-20);
   
       Pos separator1TopLeft(separator1BottomRight);
       separator1TopLeft.shiftZ(-50);
       separator1TopLeft.setY(boundaryTopLeft.getY());
   
       AABB separatorWall(-1,
                          "wall",
                          "cobblestone",
                          &separator1TopLeft,
                          &separator1BottomRight,
                          false);
       separatorWall.generateBox("fence", 0, 0, 3, 3, 1, 1);
   
       (*world).addAABB(&separatorWall);
   
       // Create Internal Separator 2
       Pos separator2BottomRight(separator1TopLeft);
       separator2BottomRight.setY(separator1BottomRight.getY());
   
       Pos separator2TopLeft(separator2BottomRight);
       separator2TopLeft.shiftX(-25);
       separator2TopLeft.setY(boundaryTopLeft.getY());
   
       AABB separatorWall2(-2,
                           "wall",
                           "cobblestone",
                           &separator2TopLeft,
                           &separator2BottomRight,
                           false);
       separatorWall2.generateBox("fence", 1, 1, 3, 3, 0, 0);
       (*world).addAABB(&separatorWall2);
   }
   
   World generateZombieWorld() {
       int N = 3;
       int sep = 15;
       int AABB_size = 10;
       string AABB_material = "planks";
   
       World world;
       generateAABBGrid(&world, N, sep, AABB_size, AABB_material);
       generateBlocks(&world);
       generateBoundingWalls(&world);
       return world;
   }
   
   int main(int argc, char* argv[]) {
   
       string jsonPath =
           "../../../../external/malmo/Minecraft/run/procedural.json";
       string tsvPath =
           "../../../../external/malmo/Minecraft/run/procedural.tsv"; // Default
                                                                      // locations
   
       // Handle options
       po::options_description desc("Allowed options");
       desc.add_options()("help", "produce help message")(
           "json_path",
           po::value<std::string>(),
           "Specify where to save the JSON file with filename an extension. "
           "Defaults to procedural.json in Minecraft/run/")(
           "tsv_path",
           po::value<std::string>(),
           "Specify where to save the TSV file with filename an extension. "
           "Defaults to procedural.tsv in Minecraft/run/");
   
       po::variables_map vm;
       po::store(po::command_line_parser(argc, argv).options(desc).run(), vm);
       po::notify(vm);
   
       if (vm.count("help")) {
           cout << desc << endl;
           return 0;
       }
   
       if (vm.count("json_path")) {
           jsonPath = vm["json_path"].as<std::string>();
       }
   
       if (vm.count("tsv_path")) {
           tsvPath = vm["tsv_path"].as<std::string>();
       }
   
       // Process input and generate output
       cout << "Generating gridworld..." << endl;
       World world = generateZombieWorld();
       cout << "Writing to file..." << endl;
   
       // Write JSON
       ofstream outputJSON(jsonPath, ios::out);
       outputJSON << world.toJSON();
       outputJSON.close();
   
       // Write TSV
       ofstream outputTSV(tsvPath, ios::out);
       outputTSV << world.toTSV();
       outputTSV.close();
   
       cout << "Done. The generated files are in Minecraft/run/procedural.json "
               "and Minecraft/run/procedural.tsv"
            << endl;
   
       return 0;
   }
