
.. _program_listing_file_src_cpp_model_sampling_GibbsSampler.h:

Program Listing for File GibbsSampler.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_cpp_model_sampling_GibbsSampler.h>` (``src/cpp/model/sampling/GibbsSampler.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "Sampler.h"
   
   #include "../utils/Definitions.h"
   
   namespace tomcat {
       namespace model {
   
           class GibbsSampler : public Sampler {
             public:
               //------------------------------------------------------------------
               // Constructors & Destructor
               //------------------------------------------------------------------
   
               GibbsSampler(std::shared_ptr<DynamicBayesNet> model,
                            int burn_in_period);
   
               ~GibbsSampler();
   
               //------------------------------------------------------------------
               // Copy & Move constructors/assignments
               //------------------------------------------------------------------
               GibbsSampler(const GibbsSampler& sampler);
   
               GibbsSampler& operator=(const GibbsSampler& sampler);
   
               GibbsSampler(GibbsSampler&&) = default;
   
               GibbsSampler& operator=(GibbsSampler&&) = default;
   
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
               void sample_latent(std::shared_ptr<gsl_rng> random_generator,
                                  int num_samples) override;
   
               Tensor3
               get_samples(const std::string& node_label) const override;
   
               void get_info(nlohmann::json& json) const override;
   
             protected:
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
               void copy_sampler(const GibbsSampler& sampler);
   
             private:
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               void
               fill_initial_samples(std::shared_ptr<gsl_rng> random_generator);
   
               void init_samples_storage(
                   int num_samples,
                   std::vector<std::shared_ptr<Node>> latent_nodes);
   
               void sample_data_node(std::shared_ptr<gsl_rng> random_generator,
                                     std::shared_ptr<Node> node,
                                     bool discard);
   
               void
               sample_parameter_node(std::shared_ptr<gsl_rng> random_generator,
                                     std::shared_ptr<Node> node,
                                     bool discard);
   
               Eigen::MatrixXd get_weights_for(const std::shared_ptr<Node>& node);
   
               void keep_sample(const std::shared_ptr<RandomVariableNode>& node,
                                const Eigen::MatrixXd& sample);
   
               void reset();
   
               //------------------------------------------------------------------
               // Data members
               //------------------------------------------------------------------
               int burn_in_period = 0;
   
               // Container to store the samples generated by this sampler.
               // Different from the Ancestral sampler, where the generated samples
               // are store as nodes' assignments, in the Gibbs sampler, for each
               // latent node, one sample is generate at a time and kept as that
               // node's assignment until the next round. Another structure is then
               // needed to stored the samples that were generated along the
               // process.
               std::unordered_map<std::string, Tensor3> node_label_to_samples;
   
               int iteration = 0;
           };
   
       } // namespace model
   } // namespace tomcat
