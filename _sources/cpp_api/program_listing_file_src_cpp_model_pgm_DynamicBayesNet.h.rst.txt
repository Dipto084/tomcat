
.. _program_listing_file_src_cpp_model_pgm_DynamicBayesNet.h:

Program Listing for File DynamicBayesNet.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_cpp_model_pgm_DynamicBayesNet.h>` (``src/cpp/model/pgm/DynamicBayesNet.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <memory>
   #include <string>
   #include <utility>
   #include <vector>
   
   #include <boost/graph/adjacency_list.hpp>
   
   #include "../utils/Definitions.h"
   #include "RandomVariableNode.h"
   
   namespace tomcat {
       namespace model {
   
           //------------------------------------------------------------------
           // Structs
           //------------------------------------------------------------------
           struct VertexData {
               // This needs to be a shared pointer because some of the nodes can
               // be parameter nodes sharable among some CPDs
               std::shared_ptr<RandomVariableNode> node;
           };
   
           class DynamicBayesNet {
             public:
               //------------------------------------------------------------------
               // Types, Enums & Constants
               //------------------------------------------------------------------
               typedef std::pair<std::shared_ptr<RandomVariableNode>,
                                 std::shared_ptr<RandomVariableNode>>
                   Edge;
   
               //------------------------------------------------------------------
               // Constructors & Destructor
               //------------------------------------------------------------------
   
               DynamicBayesNet();
   
               DynamicBayesNet(int num_node_templates);
   
               ~DynamicBayesNet();
   
               //------------------------------------------------------------------
               // Copy & Move constructors/assignments
               //------------------------------------------------------------------
               DynamicBayesNet(const DynamicBayesNet&) = default;
   
               DynamicBayesNet& operator=(const DynamicBayesNet&) = default;
   
               DynamicBayesNet(DynamicBayesNet&&) = default;
   
               DynamicBayesNet& operator=(DynamicBayesNet&&) = default;
   
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               void add_node_template(const RandomVariableNode& node);
   
               void unroll(int time_steps, bool force);
   
               void check();
   
               std::vector<std::shared_ptr<Node>> get_parameter_nodes();
   
               std::vector<std::shared_ptr<Node>>
               get_nodes_by_label(const std::string& node_abel) const;
   
               std::vector<std::shared_ptr<Node>>
               get_nodes_topological_order(bool from_roots_to_leaves = true) const;
   
               std::vector<std::shared_ptr<Node>>
               get_parent_nodes_of(const std::shared_ptr<Node>& node,
                                   bool exclude_parameters) const;
   
               std::vector<std::shared_ptr<Node>>
               get_child_nodes_of(const std::shared_ptr<Node>& node) const;
   
               void save_to_folder(const std::string& output_folder) const;
   
               void load_from_folder(const std::string& input_folder);
   
               std::vector<Edge> get_edges() const;
   
               // --------------------------------------------------------
               // Getters & Setters
               // --------------------------------------------------------
               //            const std::vector<std::shared_ptr<RandomVariableNode>>
               //            get_nodes() const;
               //
               //            const std::vector<RandomVariableNode>&
               //            get_node_templates() const;
   
               int get_time_steps() const;
   
             private:
               //------------------------------------------------------------------
               // Types, Enums & Constants
               //------------------------------------------------------------------
   
               // The graph is defined as bidirectional to speed up the access to
               // the list of parents and children of a vertex. However, only
               // single-direction edges will be created in reality.
               typedef boost::adjacency_list<boost::vecS,
                                             boost::vecS,
                                             boost::bidirectionalS,
                                             VertexData>
                   Graph;
   
               typedef std::unordered_map<std::string, int> IDMap;
   
               //------------------------------------------------------------------
               // Member functions
               //------------------------------------------------------------------
   
               void reset();
   
               void create_vertices_from_nodes();
   
               VertexData add_vertex(const RandomVariableNode& node_template,
                                     int time_step);
   
               void create_edges();
   
               void add_edge(const NodeMetadata& source_node_metadata,
                             const NodeMetadata& target_node_metadata,
                             bool time_crossing,
                             int target_time_step);
   
               void set_nodes_cpd();
   
               void update_cpd_templates_dependencies();
   
               //------------------------------------------------------------------
               // Data members
               //------------------------------------------------------------------
               Graph graph;
   
               IDMap name_to_id;
   
               // List of concrete timed instances node of the unrolled DBN.
               std::vector<std::shared_ptr<Node>> nodes;
   
               // Mapping between a timed instance parameter node's label and its
               // node object.
               Node::NodeMap parameter_nodes_map;
   
               // Mapping between a node label and all of the timed instance nodes
               // created from the template with such label.
               std::unordered_map<std::string, std::vector<std::shared_ptr<Node>>>
                   label_to_nodes;
   
               // Node templates will be used to create concrete instances of
               // nodes over time (timed node instances/objects), which will be
               // stored in the vertices of the unrolled DBN.
               //
               // The original list is preserved to allow multiple calls of the
               // unrolled method based on the original set of nodes.
               // TODO - change to a set to forbid adding the same node multiple
               //  times
               std::vector<RandomVariableNode> node_templates;
   
               // If unrolled, the number of time steps the DBN was unrolled into
               int time_steps = 0;
           };
   
       } // namespace model
   } // namespace tomcat
